colour_by = "pct_counts_MT",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "sc3_8_clusters",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "pct_counts_top_50_features_endogenous",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "pct_counts_MT",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "sc3_8_clusters",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "pct_counts_top_50_features_endogenous",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "sc3_8_log2_outlier_score",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "INS",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "CRP",
size_by="sc3_8_log2_outlier_score",
perplexity=20,rand_seed=100
)
plotTSNE(
sce.qc[endog_genes, ],
colour_by = "sc3_8_clusters",
size_by="CRP",
perplexity=20,rand_seed=100
)
# use the same gene filter as in SC3
input <- logcounts(sce.qc[rowData(sce.qc)$sc3_gene_filter, ])
# run pcaReduce 1 time creating hierarchies from 1 to 30 clusters
pca.red <- PCAreduce(t(input), nbt = 1, q = 30, method = 'S')[[1]]
library(pcaReduce)
library(pcaMethods)
# run pcaReduce 1 time creating hierarchies from 1 to 30 clusters
pca.red <- PCAreduce(t(input), nbt = 1, q = 30, method = 'S')[[1]]
library(pcaReduce)
install.packages("pcaReduce")
PCAreduce <- function(D_t, nbt, q, method){
Y <- prep(D_t, scale="none", center=TRUE)
pca_out <- pca(Y, method="svd", center = FALSE, nPcs=q)
x <- pca_out@scores
if (method == "S"){
Cl_history <- list() # nbt length
for (t in 1:nbt){
dat <- x
q <- ncol(dat)
K <- q + 1
KM <- kmeans(dat, K)
cent <- KM$centers
cl_id <- KM$cluster
Cl_mat <- c(cl_id)
Q <- q-1
for (i in 1:Q){
mrg <- MergeS(dat, cl_id, cent, K)
cl_id[which(cl_id==mrg[[1]][2])] <- mrg[[1]][1]
cent[mrg[[1]][1],] <- mrg[[2]][1] * cent[mrg[[1]][1],] + mrg[[2]][2] * cent[mrg[[1]][2],]
cent <- cent[-mrg[[1]][2],-ncol(cent)]
a <- unique(cl_id)
Omega <- seq(1, max(a), 1)
b <- setdiff(Omega, a)
N <- length(b)
if (N>0){
for (ii in 1:N){
cl_id[cl_id>b[N+1-ii]] <- cl_id[cl_id>b[N+1-ii]]-1
}
}
K <- length(unique(cl_id))
dat <- dat[,-ncol(dat)]
Cl_mat <- cbind(Cl_mat, cl_id)
}
Cl_history[[t]] <- Cl_mat
}
return(Cl_history)
}else if (method == "M"){
Cl_history<- list()
for (t in 1:nbt){
dat <- x
q <- ncol(dat)
K <- q + 1
KM <- kmeans(dat, K)
cent <- KM$centers
cl_id <- KM$cluster
Cl_mat <- c(cl_id)
Q <- q - 1
for (i in 1:Q){
mrg_ind <- MergeM(dat, cl_id, cent, K)
#cat("merge=", mrg_ind,"\n")
cl_id[which(cl_id==mrg_ind[2])] <- mrg_ind[1]
cent[mrg_ind[1],] <- mrg_ind[3] * cent[mrg_ind[1],] + mrg_ind[4] * cent[mrg_ind[2],]
cent <- cent[-mrg_ind[2],-ncol(cent)]
a <- unique(cl_id)
Omega <- seq(1, max(a), 1)
b <- setdiff(Omega, a)
N <- length(b)
if (N>0){
for (ii in 1:N){
cl_id[cl_id>b[N+1-ii]] <- cl_id[cl_id>b[N+1-ii]]-1
}
}
K <- length(unique(cl_id))
dat <- dat[,-ncol(dat)]
Cl_mat <- cbind(Cl_mat, cl_id)
}
Cl_history[[t]] <- Cl_mat
}
return(Cl_history)
}
}
# run pcaReduce 1 time creating hierarchies from 1 to 30 clusters
pca.red <- PCAreduce(t(input), nbt = 1, q = 30, method = 'S')[[1]]
library(pcaReduce)
install.packages("pcaReduce")
source('~/Documents/GitHub/pcaReduce/R/pca_reduce.R', echo=TRUE)
library(monocle)
biocLite(c("DDRTree", "pheatmap"))
biocLite(c("DDRTree", "pheatmap"))
source("http://bioconductor.org/biocLite.R")
biocLite()
sce.qc <- readRDS("~/Documents/GitHub/scImpute/scImpute.clusters4.0.rds")
pd <- new("AnnotatedDataFrame", data = sample_sheet)
pd <- new("AnnotatedDataFrame", data = colData(sce.qc))
library(monocle)
pd <- new("AnnotatedDataFrame", data = colData(sce.qc))
pd <- new("AnnotatedDataFrame", data = data.frame(colData(sce.qc)))
fd <- new("AnnotatedDataFrame", data = data.drame(rowData(sce.qc)))
fd <- new("AnnotatedDataFrame", data = data.frame(rowData(sce.qc)))
cds <- newCellDataSet(counts(sce.qc), phenoData = pd, featureData = fd)
fd <- new("AnnotatedDataFrame", data = data.frame(rownames(sce.qc)))
cds <- newCellDataSet(counts(sce.qc), phenoData = pd, featureData = fd)
suppressMessages(library(monocle))
suppressMessages(library(plyr))
suppressMessages(library(dplyr))
importCDS(sce.qc)
importCDS(sce.qc, import_all=TRUE)
HSMM <- newCellDataSet(as(counts(sce.qc), "sparseMatrix"),
phenoData = pd,
featureData = fd,
lowerDetectionLimit = 0.5,
expressionFamily = negbinomial.size())
fd <- new("AnnotatedDataFrame", data = (rownames(sce.qc)))
data.frame
cds <- newCellDataSet(as.matrix(counts(sce.qc)), phenoData = pd, featureData = fd)
library(splatter)
library(HSMMSingleCell)
data("HSMM_expr_matrix")
matrix<-counts(sce.qc)
counts <- round(matrix)
params <- splatEstimate(counts)
data("slingshotExample")
library(HSMMSingleCell)
data("slingshotExample")
suppressMessages(library(monocle))
suppressMessages(library(plyr))
importCDS(sce.qc, import_all=TRUE)
expression.data<- counts(sce.qc)
expression.data[1:10,1:5
]
sce.qc <- readRDS("~/Documents/GitHub/Single Cell RNA Seq Analysis/scImpute/scImpute.clusters4.0.rds")
expression.data<- counts(sce.qc)
expression.data<- counts(sce.qc)
expression.data[1:10,1:5
]
expression.data[1:10,1:5
]
expression.data<- counts(sce.qc)
expression.data[1:10,1:5
]
pheno.data<-colnames(expression.data)
pheno.data<-colnames(expression.data)
pheno.data.df <- data.frame(type=pheno.data) # Must be data frame object
rownames(pheno.data.df) <- colnames(expression.data) # Rownames must match expression data
pheno.data<-colData(sce.qc)$Combined.cluster
pheno.data
pheno.data<-colData(sce.qc)$Combined.cluster
pheno.data.df <- data.frame(type=pheno.data) # Must be data frame object
pheno.data.df <- data.frame(type=pheno.data) # Must be data frame object
rownames(pheno.data.df) <- colnames(expression.data) # Rownames must match expression data
pd <- new('AnnotatedDataFrame', data = pheno.data.df)
t
es_mef_CellDataSet_oedsymbol.RData
save(es.mef, file='es_mef_CellDataSet_oedsymbol.RData')
#Create CellDataSet Object
es.mef <- new('CellDataSet', exprs = expression.data, phenoData = pd)
save(es.mef, file='es_mef_CellDataSet_oedsymbol.RData')
L <- log10(exprs(es.mef)+1)
L[L==0] <- NA
melted.dens.df <- melt(t(scale(t(L))))
suppressMessages(library(plyr))
suppressMessages(library(monocle))
L <- log10(exprs(es.mef)+1)
L[L==0] <- NA
melted.dens.df <- melt(t(scale(t(L))))
library(reshape)
library(reshape)
melted.dens.df <- melt(t(scale(t(L))))
```{r}
qplot(value, geom = 'density', data = melted.dens.df) + stat_function(fun = dnorm, size = 0.5, color = 'red') + xlab('Standardized log(Expression)') + ylab('Density')
es.mef <- detectGenes(es.mef, min_expr = 0.1)
expressed.genes <- rownames(fData(es.mef))[fData(es.mef)$num_cells_expressed >= 10]
ordering.genes <- row.names(es.mef)[1:50] # Select genes used for ordering
es.mef <- setOrderingFilter(es.mef, ordering.genes) # Set list of genes for ordering
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
ordering.genes <- row.names(es.mef)[1:50] # Select genes used for ordering
es.mef <- setOrderingFilter(es.mef, ordering.genes) # Set list of genes for ordering
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
install.packages(c("VGAM", "irlba", "matrixStats", "igraph", "combinat", "fastICA", "grid", "ggplot2",  "reshape2", "plyr", "parallel", "methods"))
suppressMessages(library(monocle))
suppressMessages(library(plyr))
library(reshape)
ordering.genes <- row.names(es.mef)[1:50] # Select genes used for ordering
es.mef <- setOrderingFilter(es.mef, ordering.genes) # Set list of genes for ordering
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
suppressMessages(library(monocle))
ordering.genes <- row.names(es.mef)[1:50] # Select genes used for ordering
es.mef <- setOrderingFilter(es.mef, ordering.genes) # Set list of genes for ordering
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
library(irlba)
ordering.genes <- row.names(es.mef)[1:50] # Select genes used for ordering
es.mef <- setOrderingFilter(es.mef, ordering.genes) # Set list of genes for ordering
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
library(irlba)
es.mef <- reduceDimension(es.mef, use_irlba = F) # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none") # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method=none) # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method=NA) # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="NA") # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none") # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none") # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_exprs=0) # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_expr=0) # Reduce dimensionality
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_expr=0) # Reduce dimensionality
es.mef <- orderCells(es.mef, num_paths = 2, reverse = F) # Order cells
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_expr=0) # Reduce dimensionality
estimateSizeFactors(es.mef)
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_expr=0) # Reduce dimensionality
checkSizeFactors(es.mef)
es.mef<-estimateSizeFactors(es.mef)
es.mef <- reduceDimension(es.mef, use_irlba = F, norm_method="none", pseudo_expr=0) # Reduce dimensionality
es.mef<-estimateDispersions(es.mef)
df1$X24h_volume_usd <- as.numeric(df1$X24h_volume_usd)
library(coinmarketcapr)
ibrary(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
market_today <- get_marketcap_ticker_all()
head(market_today[,1:8])
df1 <- na.omit(market_today[,c('symbol','market_cap_usd', 'percent_change_24h', 'price_btc', 'percent_change_7d', 'total_supply','X24h_volume_usd', 'available_supply')])
#as numeric
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
df1$percent_change_24h <- as.numeric(df1$percent_change_24h)
df1$price_btc <- as.numeric(df1$price_btc)
df1$percent_change_7d <- as.numeric(df1$percent_change_7d)
df1$total_supply <- as.numeric(df1$total_supply)
df1$X24h_volume_usd <- as.numeric(df1$X24h_volume_usd)
df1$available_supply <- as.numeric(df1$available_supply)
#df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
cryptolist <- df1[1:50, 2:8]
row.names(cryptolist) <- df1[1:50,1]
#Tree Map
#treemap(df1, index = 'formatted_market_cap', vSize = 'market_cap_usd', title = 'Cryptocurrency Market Cap', fontsize.labels=c(12, 8), palette='RdYlGn')
res.pca <- prcomp(cryptolist, scale = TRUE)
fviz_eig(res.pca)
#graph of coins, similar group together
fviz_pca_ind(res.pca,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE,     # Avoid text overlapping
axes = c(1,3)
)
#graph variables - positively correlated point to same side. negative point opposite
fviz_pca_var(res.pca,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE ,    # Avoid text overlapping
axes = c(1,3)
)
#Biplot
fviz_pca_biplot(res.pca, repel = TRUE,
col.var = "#2E9FDF", # Variables color
col.ind = "#696969"  ,# Individuals color
axes = c(1,2)
)
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
#as numeric
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
df1$percent_change_24h <- as.numeric(df1$percent_change_24h)
df1$price_btc <- as.numeric(df1$price_btc)
df1$percent_change_7d <- as.numeric(df1$percent_change_7d)
df1$total_supply <- as.numeric(df1$total_supply)
df1$X24h_volume_usd <- as.numeric(df1$X24h_volume_usd)
df1$available_supply <- as.numeric(df1$available_supply)
#df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
cryptolist <- df1[1:50, 2:8]
row.names(cryptolist) <- df1[1:50,1]
#Tree Map
#treemap(df1, index = 'formatted_market_cap', vSize = 'market_cap_usd', title = 'Cryptocurrency Market Cap', fontsize.labels=c(12, 8), palette='RdYlGn')
res.pca <- prcomp(cryptolist, scale = TRUE)
fviz_eig(res.pca)
#as numeric
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
#as numeric
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
#as numeric
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
library(coinmarketcapr)
library(treemap)
library(ggplot2)
library(FactoMineR)
library(stats)
library(factoextra)
#plot_top_5_currencies()
#plot_top_5_currencies()
market_today <- get_marketcap_ticker_all()
head(market_today[,1:8])
df1 <- na.omit(market_today[,c('symbol','market_cap_usd', 'percent_change_24h', 'price_btc', 'percent_change_7d', 'total_supply','X24h_volume_usd', 'available_supply')])
plot_top_5_currencies()
market_today <- get_marketcap_ticker_all()
head(market_today[,1:8])
df1 <- na.omit(market_today[,c('symbol','market_cap_usd', 'percent_change_24h', 'price_btc', 'percent_change_7d', 'total_supply','X24h_volume_usd', 'available_supply')])
crypto_history(limit=50)
install.packages("crypto", dependencies = TRUE)
library(crypto)
crypto_history(n=5)
crypto_history(limit=5)
crypto_list()
ch<-crypto_history(limit=5)
cp<-crypto_prices()
m<-daily_market('bitcoin')
m
global_market()
ac<-global_market()
table(ac)
getCoins()
ch2.0<-crypto2xts(ch)
df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
library(treemap)
df1 <- na.omit(market_today[,c('id','market_cap_usd')])
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
treemap(df1, index = 'formatted_market_cap', vSize = 'market_cap_usd', title = 'Cryptocurrency Market Cap', fontsize.labels=c(12, 8), palette='RdYlGn')
#install.packages('shiny')
install.packages('coindeskr')
install.packages('dygraphs')
library(shiny) #To build the shiny App
library(coindeskr) #R-Package connecting to Coindesk API
library(dygraphs) #For interactive Time-series graphs
source('~/BlockChainR/BlockChainR/app.R', echo=TRUE)
install.packages("coindeskr")
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
#===============================
#library(shiny)
#install.packages('shiny')
install.packages('coindeskr')
source('~/BlockChainR/BlockChainR/app.R', echo=TRUE)
shinyapp()
shinUI
ui
#===============================
server <- function(input,output){
output$minprice <- renderText(
paste('Price : $', min(last31), '<br>Date :', rownames(last31)[which.min(last31$Price)] )
)
output$maxprice <- renderText(
paste('Price : $', max(last31), '<br>Date :', rownames(last31)[which.max(last31$Price)] )
)
output$btcprice <- renderDygraph(
dygraph(data = last31, main = "Bitcoin USD Price for Last 31 days") %>%
dyHighlight(highlightCircleSize = 5,
highlightSeriesBackgroundAlpha = 0.2,
hideOnMouseOut = FALSE, highlightSeriesOpts = list(strokeWidth = 3)) %>%
dyRangeSelector()
)
}
ui <- shinyUI(
fluidPage(
titlePanel('Bitcoin USD Price for Last 31 days'),
mainPanel(
h3('Minimum'),
h3(htmlOutput('minprice')),
h3('Maximum'),
h3(htmlOutput('maxprice')),
dygraphOutput("btcprice")
)
))
shiny::runGitHub('amrrs/Bitcoin_price_tracker_Daily')
View(server)
setwd("~/BlockChainR")
setwd("~/BlockChainR/BlockChainR")
ui <- shinyUI(
fluidPage(
titlePanel('Bitcoin USD Price for Last 31 days'),
mainPanel(
h3('Minimum'),
h3(htmlOutput('minprice')),
h3('Maximum'),
h3(htmlOutput('maxprice')),
dygraphOutput("btcprice")
)
))
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
#===============================
#library(shiny)
#install.packages('shiny')
install.packages('coindeskr')
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
#===============================
#library(shiny)
#install.packages('shiny')
install.packages('coindeskr')
source('~/BlockChainR/BlockChainR/app.R')
run
runApp()
ui
server
ui()
View(ui)
runApp
source('~/BlockChainR/BlockChainR/app.R', echo=TRUE)
install.packages("coindeskr")
install.packages("dygraphs")
install.packages("dygraphs")
server
server()
shiny::runApp
shinyApp(ui,server)
